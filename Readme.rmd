---
title: "Readme.rmd"
author: "Sergio Pedro R Oliveira"
date: "Fevereiro de 2022"
output:
  pdf_document: default
  md_document:
    variant: markdown_github
  html_document:
    df_print: paged
  word_document: default
---

# Objetivo

Estudo dirigido de SQL, utilizando SQLite.

# Livro de referência

Introdução a linguagem SQL - abordagem pratica para iniciantes

\newpage
# Assuntos por capitulos e resumos

## Capítulo 4

**SELECT**:\

- Extrai dados de uma tabela e exibe os resultados.\

- Uso do (*) para especificar todas as colunas.\

- Uso do **AS** para criar nova coluna, tambem serve para mudar nome de coluna, na consulta.\

- Uso da função *round()* para arredondamentos.\

- Uso da função *coalesce()* para alterar o valor NULL de determinada coluna para outro valor estabelecido.
Usado em conjunto com o **AS** para trocar o nome da coluna, na consulta.\

Obs.: na expressão o uso do ponto para representar o numero decimal.



**Operadores matematicos**:

```{r echo=FALSE}
library(knitr)
Operador <- c("+","-","*","/","%")
Descrição <- c("soma", "subtração",  "multiplicação", "divisão", "resto da divisão")
op_mat <- data.frame(Operador, Descrição)
op_mat
```



**Concatenação de textos**:\

- Mescla dois ou mais dados.\

- O operador de concatenação é especificado por um **pipe duplo** (||).\

- Após a mesclagem de dados o retorno é no dado tipo texto.\

Obs.: no MySQL a função que faz concatenação é **CONCAT()**.

\newpage

## Capítulo 5

**WHERE**:\

- **Filtro** de dados(registros) para consulta.\

  - Consultas atraves de criterios **matematicos**.\

  - Consultas atraves de criterios em formato **texto**.\
  
- Uso da função *length* em conjunto com **WHERE**, função para determinar o numero de caracteres.\

- Uso do **BETWEEN** para filtragem inclusiva de dados, buscar dados entre valores.\

- Uso da expressão **LIKE**, para utilização de caracteres curingas na utilização de filtros.\

- Uso de operadores logicos para auxilar na filtragem de dados:\
  - *OR*\
  Uso de mais de um criterio para filtragem.\
  
  - *AND*\
  Criterios bem definidos\


tabela verdade:
```{r echo=FALSE}
data.frame(p=c("V","V","F","F"),NOT_p= c("F","F","V","V"), q=c("V","F","V","F"),NOT_q= c("F","V","F","V"),
           p_AND_q= c("V","F","F","F"), p_OR_q = c("V","V","V","F"))

```


- Uso de **listas**:\
  - *IN*\
  fornece uma lista validade valores como criterio de filtragem.\
  
  - *NOT IN*\
  Todos os dados, exceto os fornecidos pela lista.\

```{r echo=FALSE}
Operador <- c("AND","OR","BETWEEN","IN","NOT","IS NULL","IS NOT NULL")
Descricao_op_logc <- c("Verifica se todas as expressões booleanas são verdadeiras",
               "Verifica se alguma expressão booleana é verdadeira",
               "Verifica se um valor se encaixa inclusivamente dentro de um intervalo",
               "Verifica se um valor existe dentro de uma lista de valores",
               "Nega e inverte o valor em uma expressão booleana",
               "Verifica se um valor é nulo","Verifica se um valor não é nulo")
Exemplo <- c("x AND y","x OR y","a BETWEEN x AND y","a IN (x,y,w,z)","a NOT IN (x,y,w,z)",
             "a IS NULL","a IS NOT NULL")
op_logic <- data.frame(Operador,Descricao_op_logc,Exemplo)
op_logic
```

- uso de *booleanos* no filtro, em conjunto com NOT para transformar um true em false (1 -> 0).\
  
  - **true** = 1.\
  
  - **false** = 0.\

obs.: SQLite só aceita 1 e 0. MySQL aceita true e false.\

- Tratamento de NULL, valor nulo.

  - funções para trabalhar com NULL:

    - **IS NULL**\
    Filtra valores NULL.\

    - **IS NOT NULL**\
    Filtra valores não NULL.\
    
    - **IS NULL OR**\
    Adiciona NULL a filtragem, junto de outros criterios.\

    - *coalesce*\
    Transforma valores NULL em outra coisa.\

Obs.: em situação normal, o valor NULL é ignorado pelos filtros matematicos, se não especificado.\

\newpage

## Capítulo 6

**GROUP BY** e **ORDER BY**\
Agragação de dados, também conhecido como totalização, resumo ou agrupamento.\

## GROUP BY
- Agrupamento de registros.\
- É comum ser usado em conjunto com **WHERE** para selecionar dados.\
- Normalmente é usado com conjunto com funções tipicas de sumarização (resumo), como:\
```{r echo=FALSE}
library(base)
Funcao <- c('avg(X)','count(X)','count(*)','max(X)','min(X)','sum(X)','group_concat(X)')
Descricao_func_tipica_groupby <- c('Calcula a media de todos os valores da coluna X (Omite valores nulos)',
               'Contao o numero de valore não nulos da coluna X',
               'Conta o numero registros',
               'Encontra o valor maximo da coluna X (Omite valores nulos)',
               'Encontra o valor minimo da coluna X (Omite valores nulos)',
               'Calcula a soma dos valores da coluna X (Omite valores nulos)',
               'Concatena os valores não nulos da coluna X.**')
funcs_agregacao <- data.frame(Funcao, Descricao_func_tipica_groupby)
funcs_agregacao

```
**Obs.: Você também pode fornecer um segundo argumento que especifica um separador, como a virgula.\
- Existem duas formas possiveis de escrever os argumentos de **GROUP BY**:\

  1. Escrevendo o nome das colunas especificadas em **SELECT**.\

  2. Dando o numero da ordem das colunas que aparecem especificadas em **SELECT**.\
  Essa segunda forma não funciona no Oracle e no SQL Server.\


## ORDER BY
- Ordenando registros.\
- Por padrão a instrução ORDER BY organiza por ordem crescente os registros.\
- Operadores **ORDER BY**:

  1. **ASC**\
  Organiza os registros. em ordem crescente \
  
  2. **DESC**\
  Organiza os registros em ordem decrescente.\

## HAVING
- Filtra registros de acordo com um valor agregado.\
- Substitui o **WHERE** para filtrar valores agregados por **GROUP BY**.\
- Sintaxe no Oracle é ligeiramente diferente, é preciso especificar a função de agregação ao usar o **HAVING**.\
ex.: HAVING **SUM**(precipitation) > 30\

## DISTINCT
- Instrução para obter registros distintos, sem duplicatas, sem valores repetidos.\

\newpage

# Andamento dos Estudos

## Assunto em andamento:

## Em andamento:

## Vazios:

## Finalizando detalhes: